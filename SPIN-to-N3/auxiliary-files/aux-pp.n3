@prefix aux: <http://example.org/aux#> .
@prefix e: <http://eulersharp.sourceforge.net/2003/03swap/log-rules#> .
@prefix list: <http://www.w3.org/2000/10/swap/list#> .
@prefix log: <http://www.w3.org/2000/10/swap/log#> .
@prefix math: <http://www.w3.org/2000/10/swap/math#> .
@prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#> .
@prefix sp: <http://spinrdf.org/sp#> .
@prefix string: <http://www.w3.org/2000/10/swap/string#> .

# collect path steps for easier processing
# (also, flatten seq, alt paths)

#
{
   ?x aux:collectPathSteps ?paths 
}
<= 
{
   ?x a sp:SeqPath ;
       sp:path1 ?p1 ;
       sp:path2 ?p2 .
   # - flatten seq paths
   ?p1 aux:collectPathSteps ?p1s .
   ?p2 aux:collectPathSteps ?p2s .
   ( ?p1s ?p2s ) list:append ?paths .
} .

#
{
   ?x aux:collectPathSteps ?paths 
}
<= 
{
   ?x a sp:ReversePath ;
       sp:subPath ?p .
   ?p aux:collectPathSteps ?ps .
   ?paths log:equalTo ( ( ?ps "rev" ) ) 
} .

#
{
   ?x aux:collectPathSteps ?paths 
}
<= 
{
   ?x a sp:AltPath ;
       sp:path1 ?p1 ;
       sp:path2 ?p2 .
   # - flatten alt paths
   ?p1 aux:collectPathSteps ?p1s .
   ?p2 aux:collectPathSteps ?p2s .
   ?paths log:equalTo ( ( ?p1s ?p2s ) "alt" ) .
} .

#
{
   ?x aux:collectPathSteps ?paths 
}
<= 
{
   ?x a sp:ModPath ;
       sp:subPath ?p ;
       sp:modMin ?min ;
       sp:modMax ?max .
   ?p aux:collectPathSteps ?ps .
   ?paths log:equalTo ( ( ?ps ?min ?max ) ) 
} .

#
{
   ?x aux:collectPathSteps ?paths 
}
<= 
{
   ?x a sp:NegatedPath ;
       sp:subPath ?options .
   
   ?paths log:equalTo ( ?options "neg" )
} .

#
{
   ?x aux:collectPathSteps ?paths
}
<= 
{
   ?x log:rawType log:Other .
   ?x!log:uri string:notMatches "http://spinrdf.org/sp#(SeqPath|AltPath|ModPath|NegatedPath)" .
   ?paths log:equalTo ( ( ?x 1 1 ) ) .
} .
