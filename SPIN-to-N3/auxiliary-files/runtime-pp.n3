@prefix : <http://example.org/aux#> .
@prefix aux: <http://example.org/aux#> .
@prefix e: <http://eulersharp.sourceforge.net/2003/03swap/log-rules#> .
@prefix list: <http://www.w3.org/2000/10/swap/list#> .
@prefix log: <http://www.w3.org/2000/10/swap/log#> .
@prefix math: <http://www.w3.org/2000/10/swap/math#> .
@prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
@prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#> .
@prefix sp: <http://spinrdf.org/sp#> .
@prefix string: <http://www.w3.org/2000/10/swap/string#> .


# - sequenceOfSteps

#
{
   ( ?start ?end ) aux:stepThroughPath ?steps 
}
<= 
{
   ?steps list:firstRest ( ?step ?rest ) .
   # steps = list with steps (again lists) as elements
   # (individual steps would have numbers as last elements)
   ?steps!list:last log:rawType rdf:List .
   # rest not empty yet
   #
   ?steps list:last ?last .
   "listOfSteps" log:trace ( ?start ?end ?step ) .
   ( ?start ?interm ) aux:stepThroughPath ?step .
   #
   ( ?interm ?end ) aux:stepThroughPath ?rest 
} .

# rest is empty: unify "start" with "end"
{
   ( ?start ?start ) aux:stepThroughPath ( ) 
}
<= {} .


# - singleStep
{
   ( ?s ?o ) aux:stepThroughPath ( ?pred 1 1 ) 
}
<= 
{
   #"singleStep" log:trace ( ?s ?o ?pred ) .
   ?s ?pred ?o 
} .


# - oneOrMoreSequence
{
   ( ?start ?end ) aux:stepThroughPath ( ?nested 1 -2 ) 
}
<= 
{
   #"oneOrMoreSteps" log:trace ( ?start ?end ?nested ) .
   ( ?start ?end ) aux:stepThroughPath ?nested .
} .

#
{
   ( ?start ?end ) aux:stepThroughPath ( ?nested 1 -2 ) 
}
<= 
{
   ( ?start ?o ) aux:stepThroughPath ?nested .
   ( ?o ?end ) aux:stepThroughPath ( ?nested 1 -2 ) .
} .


# - zeroOrMoreSequence
{
   ( ?start ?start ) aux:stepThroughPath ( ?nested 0 -2 ) 
}
<= {} .

#
{
   ( ?start ?end ) aux:stepThroughPath ( ?nested 0 -2 ) 
}
<= 
{
   ( ?start ?end ) aux:stepThroughPath ( ?nested 1 -2 ) 
} .


# - optional
{
   ( ?start ?start ) aux:stepThroughPath ( ?nested 0 -1 ) 
}
<= {} .
{
   ( ?start ?end ) aux:stepThroughPath ( ?nested 0 -1 ) 
}
<= 
{
   ( ?start ?end ) aux:stepThroughPath ?nested .
} .



# CHAIN PREDICATES
# - optional chain
#
{
   ( ?a ?a ) :optionalChain ?predicate .
}
<= {} .

#
{
   ( ?a ?b ) :optionalChain ?predicate .
}
<= 
{
   ( ?a ?b ) :chain ?predicate .
} .


# - chain
#
{
   ( ?a ?b ) :chain ?predicate .
}
<= 
{
   ?a ?predicate ?b .
} .

#
{
   ( ?a ?x ) :chain ?predicate .
}
<= 
{
   ?a ?predicate ?b .
   ( ?b ?x ) :chain ?predicate 
} .


# - optional
#
{
   ( ?a ?a ) :optional ?predicate 
}
<= {} .

#
{
   ( ?a ?b ) :optional ?predicate 
}
<= 
{
   ?a ?predicate ?b 
} .
