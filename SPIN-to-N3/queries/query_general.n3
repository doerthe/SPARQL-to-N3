@prefix math: <http://www.w3.org/2000/10/swap/math#> . 
@prefix string: <http://www.w3.org/2000/10/swap/string#> .
@prefix list: <http://www.w3.org/2000/10/swap/list#> .
@prefix log: <http://www.w3.org/2000/10/swap/log#> .
@prefix xsd: <http://www.w3.org/2001/XMLSchema#> .
@prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#> .
@prefix spin: <http://spinrdf.org/spin#>.
@prefix sp: <http://spinrdf.org/sp#>.
@prefix ex: <http://example.org/spin#>.
@prefix e: <http://eulersharp.sourceforge.net/2003/03swap/log-rules#>.
@prefix aux: <http://example.org/aux#>.

# rule to generate rule
{   ?x a       sp:Construct ;
      sp:templates ?temps ;
      sp:where ?where.
 	    ?where aux:createGraph ?g1.
      ?temps aux:handleTriples ?g2
	}=>{?g1=>?g2. }.

  # rule to generate rule
  {   ?x a       sp:Ask ;
        sp:where ?where.
   	   ?where aux:createGraph ?g1.
  	}=>{?g1 => {[] ex:result true}. {(1 ?g1 ()) log:collectAllIn ?scope}=>{[] ex:result false}
    }.


## select with aggregates
# (no group-by)
# {     ?x a sp:Select .

#       ?x!sp:resultVariables list:member ?resultVar .
#       ?resultVar sp:expression ?exp .

#       _:t log:notIncludes { ?x sp:groupBy ?g } .

#       ?exp a ?aggrFn .
#       ?exp!sp:expression!sp:varName e:skolem ?aggrVar .
#       ?resultVar sp:varName ?aggrAlias .

#       ?x!sp:where aux:createGraph ?g .

# } => {
#       { 
#             ( ?values ?g ?pairs ) log:collectAllIn _:t .

#             ?values ?aggrFn ?result .
#             ( ?aggrAlias ?result ) log:equalTo ?resultCell .

#       } => { [] ex:result ?resultCell } .
# } .


## select with aggregates
{     ?x a sp:Select .
      ?x!sp:groupBy!list:member!sp:varName e:skolem ?groupVar .

      ?x!sp:resultVariables list:member ?resultVar .
      ?resultVar sp:expression ?exp .
      ?exp a ?aggrFn .
      ?exp!sp:expression!sp:varName e:skolem ?aggrVar .
      ?resultVar sp:varName ?aggrAlias .

      ?x!sp:where aux:createGraph ?g .

} => {
      { 
            ( ( ?groupVar ?aggrVar ) ?g ?pairs ) 
                  log:collectAllIn _:t .

            # get all groupVar values from these pairs
            ( ?groupVal { ?pairs list:member ?pair . ( ?pair 0 ) list:memberAt ?groupVal } ?groupVals )
                  log:collectAllIn _:t .

            # get all unique groupVar values
            ?groupVals list:removeDuplicates ?uniqueGroupVals .

            # "uniqueGroupVals" log:trace ( ?uniqueGroupVals ) .

            ( ?resultCell
            {
                  # for each unique groupVar value
                  ?uniqueGroupVals list:member ?groupVal .
                  # "groupVal" log:trace ( ?groupVal ) .

                  # collect all corresponding aggrVar values
                  ( ?val
                  {
                        ?pairs list:member ?pair .
                        ( ?pair 0 ) list:memberAt ?groupVal .
                        ( ?pair 1 ) list:memberAt ?val
                  } ?values ) log:collectAllIn _:t .
                  
                  ?values ?aggrFn ?result .
                  # "result" log:trace ( ?values ?aggrFn ?result ) .

                  ( ?aggrAlias ?result ) log:equalTo ?resultCell .

            } ?resultCells ) log:collectAllIn _:t .

            # "resultCells" log:trace ( ?resultCells ) .

      } => { [] ex:result ?resultCells } .
} .


## select
{     ?x a sp:Select .
      _:t log:notIncludes { ?x!sp:resultVariables!list:member sp:expression ?e } .

      ?x  sp:where ?where.
      ?x aux:getResultVariables ?outvars.
      ?where aux:createGraph ?g1.

  }=>{?g1 => {[] ex:result ?outvars}.
  }.