@prefix math: <http://www.w3.org/2000/10/swap/math#> . 
@prefix string: <http://www.w3.org/2000/10/swap/string#> .
@prefix list: <http://www.w3.org/2000/10/swap/list#> .
@prefix log: <http://www.w3.org/2000/10/swap/log#> .
@prefix xsd: <http://www.w3.org/2001/XMLSchema#> .
@prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#> .
@prefix spin: <http://spinrdf.org/spin#>.
@prefix sp: <http://spinrdf.org/sp#>.
@prefix ex: <http://example.org/spin#>.
@prefix e: <http://eulersharp.sourceforge.net/2003/03swap/log-rules#>.
@prefix aux: <http://example.org/aux#>.

# rule to generate rule
{   ?x a       sp:Construct ;
      sp:templates ?temps ;
      sp:where ?where.
 	    ?where aux:createGraph ?g1.
      ?temps aux:handleTriples ?g2
	}=>{?g1=>?g2. }.

  # rule to generate rule
  {   ?x a       sp:Ask ;
        sp:where ?where.
   	   ?where aux:createGraph ?g1.
  	}=>{?g1 => {[] ex:result true}. {(1 ?g1 ()) log:collectAllIn ?scope}=>{[] ex:result false}
    }.


# TODO
## select with aggregates
# (no group-by)

## select (with aggregate result variables)
{     ?x a sp:Select ;
            sp:groupBy ?z .

      # TODO check whether output variable names is a subset of group variable names 
      # if not, "throw" an error ...

      ( ( ?groupVarName ?groupVar ) 
      {     ?x!sp:groupBy!list:member sp:varName ?groupVarName .
            ?groupVarName e:skolem ?groupVar 

      } ?groups ) log:collectAllIn _:t .

      ( ?groupVar { ?groups list:member ?group . ( ?group 1) list:memberAt ?groupVar } ?groupVars ) 
            log:collectAllIn _:t .

      ( ( ?aggrFn ?aggrVar ?aggrAlias )
      {
            ?x!sp:resultVariables list:member ?resultVar .
            ?resultVar sp:expression ?exp .
            ?exp a ?aggrFn .
            ?exp!sp:expression!sp:varName e:skolem ?aggrVar .
            ?resultVar sp:varName ?aggrAlias .

      } ?aggrs ) log:collectAllIn _:t .

      ( ?aggrVar { ?aggrs list:member ?aggr . ( ?aggr 1 ) list:memberAt ?aggrVar } ?aggrVars ) 
            log:collectAllIn _:t .

      ?x!sp:where aux:createGraph ?g .

} => {
      {     # collect all relevant variable values from the WHERE clause
            ( ( ?groupVars ?aggrVars ) ?g ?pairs ) log:collectAllIn _:t .

            "pairs" log:trace ( ?pairs ) .

            # get all group-variable(s) values from these pairs
            ( ?groupVal { ?pairs list:member ?pair . ( ?pair 0 ) list:memberAt ?groupVal } ?groupVals )
                  log:collectAllIn _:t .

            # get all unique group-variables values
            ?groupVals list:removeDuplicates ?uniqueGroupVals .
            "uniqueGroupVals" log:trace ( ?uniqueGroupVals ) .

            # for each unique group-variables value
            ?uniqueGroupVals list:member ?groupVal .
            "groupVal" log:trace ( ?groupVal ) .

            # collect all corresponding aggr-variables values
            ( ?aggrValueList
            {
                  ?pairs list:member ?pair .
                  ( ?pair 0 ) list:memberAt ?groupVal .
                  ( ?pair 1 ) list:memberAt ?aggrValueList
                  
            } ?aggrValueLists ) log:collectAllIn _:t .
            
            # per unique group-variables combination: 
            # a list of values, one for each aggr-variable
            "aggrValueLists" log:trace ( ?aggrValueLists ) .
            
            ( ?aggrResultCell
            { 
                  # for each aggr-variable entry
                  ?aggrs list:iterate ( ?i ( ?aggrFn ?aggrVar ?aggrAlias ) ) .
                  "aggr" log:trace ( ?aggrFn ?aggrVar ?aggrAlias ) .  

                  # get all values of the corresponding aggr-variable
                  ( ?aggrValue
                  {
                        ?aggrValueLists list:member ?aggrValueList .
                        ( ?aggrValueList ?i ) list:memberAt ?aggrValue .
                  
                  } ?aggrValues ) log:collectAllIn _:t .

                  # finally, apply the aggr function on the values for the aggr-variable
                  ?aggrValues ?aggrFn ?result .
                  "result" log:trace ( ?aggrValues ?aggrFn ?result ) .

                  ( ?aggrAlias ?result ) log:equalTo ?aggrResultCell .
            
            } ?aggrResultCells ) log:collectAllIn _:t .
            
            "aggrResultCells" log:trace ( ?aggrResultCells ) .

            # for each group-variable being returned, get the group value
            ( ( ?indivGroupVal ?groupVarName )
            {
                  ?groups list:iterate ( ?i ?group ) .
                  # group-variable name
                  ( ?group 0 ) list:memberAt ?groupVarName .

                  # group-variable value
                  ( ?groupVal ?i ) list:memberAt ?indivGroupVal .
            
            } ?groupResultCells ) log:collectAllIn _:t .

            "groupResultCells" log:trace ( ?groupResultCells ) .

            ( ?aggrResultCells ?groupResultCells ) list:append ?resultCell .

      } => { [] ex:result ?resultCell } .
} .


## select (without aggregate result variables)
{     ?x a sp:Select .
      # does not include any expressions as result variables (i.e., aggregate functions)
      (?e { ?x!sp:resultVariables!list:member sp:expression ?e } ()) log:collectAllIn _:t .

      ?x  sp:where ?where.
      ?x aux:getResultVariables ?outvars.
      ?where aux:createGraph ?g1.

  }=>{?g1 => {[] ex:result ?outvars}.
  }.