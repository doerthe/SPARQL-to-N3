@prefix math: <http://www.w3.org/2000/10/swap/math#> . 
@prefix string: <http://www.w3.org/2000/10/swap/string#> .
@prefix list: <http://www.w3.org/2000/10/swap/list#> .
@prefix log: <http://www.w3.org/2000/10/swap/log#> .
@prefix xsd: <http://www.w3.org/2001/XMLSchema#> .
@prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#> .
@prefix spin: <http://spinrdf.org/spin#>.
@prefix sp: <http://spinrdf.org/sp#>.
@prefix ex: <http://example.org/spin#>.
@prefix e: <http://eulersharp.sourceforge.net/2003/03swap/log-rules#>.
@prefix aux: <http://example.org/aux#>.

# rule to generate rule
{   ?x a       sp:Construct ;
      sp:templates ?temps ;
      sp:where ?where.
 	    ?where aux:createGraph ?g1.
      ?temps aux:handleTriples ?g2
	}=>{?g1=>?g2. }.

  # rule to generate rule
  {   ?x a       sp:Ask ;
        sp:where ?where.
   	   ?where aux:createGraph ?g1.
  	}=>{?g1 => {[] ex:result true}. {(1 ?g1 ()) log:collectAllIn ?scope}=>{[] ex:result false}
    }.


## select with aggregates (no group-by)

{     ?x a sp:Select .
      _:t log:notIncludes { ?x sp:groupBy ?z } .

      # get all aggregates (function, var, alias)
      ( ( ?aggrFn ?aggrVar ?aggrAlias )
      {
            ?x!sp:resultVariables list:member ?resultVar .
            ?resultVar sp:expression ?exp .
            ?exp a ?aggrFn .
            ?exp!sp:expression!sp:varName e:skolem ?aggrVar .
            ?resultVar sp:varName ?aggrAlias .

      } ?aggrs ) log:collectAllIn _:t .

      # from these, get aggr-variable vars
      ( ?aggrVar { ?aggrs list:member ?aggr . ( ?aggr 1 ) list:memberAt ?aggrVar } ?aggrVars ) 
            log:collectAllIn _:t .

      # get the N3 equivalent of the where clause
      ?x!sp:where aux:createGraph ?g .

} => {
      {     # collect all relevant variable values from the WHERE clause
            ( ?aggrVars ?g ?aggrValueLists ) log:collectAllIn _:t .

            # "pairs" log:trace ( ?aggrValueLists ) .
            
            ( ?aggrResultCell
            { 
                  # for each aggr-variable entry
                  ?aggrs list:iterate ( ?i ( ?aggrFn ?aggrVar ?aggrAlias ) ) .
                  # "aggr" log:trace ( ?aggrFn ?aggrVar ?aggrAlias ) .  

                  # get all values of the corresponding aggr-variable
                  ( ?aggrValue
                  {
                        ?aggrValueLists list:member ?aggrValueList .
                        ( ?aggrValueList ?i ) list:memberAt ?aggrValue .
                  
                  } ?aggrValues ) log:collectAllIn _:t .

                  # finally, apply the aggr function on the values for the aggr-variable
                  ?aggrValues ?aggrFn ?result .
                  # "result" log:trace ( ?aggrValues ?aggrFn ?result ) .

                  ( ?aggrAlias ?result ) log:equalTo ?aggrResultCell .
            
            } ?aggrResultCells ) log:collectAllIn _:t .
            
            # "aggrResultCells" log:trace ( ?aggrResultCells ) .

      } => { [] ex:result ?aggrResultCells } .
} .


## select with aggregates (group-by)
{     ?x a sp:Select ;
            sp:groupBy ?z .

      # get all group-variable names
      ( ?groupVarName { ?x!sp:groupBy!list:member sp:varName ?groupVarName } ?groupVarNames ) 
            log:collectAllIn _:t .

      # get all group-variable vars
      ( ?groupVar { ?groupVarNames!list:member e:skolem ?groupVar } ?groupVars ) 
            log:collectAllIn _:t .

      # get all select-variable names
      ( ?selectVarName { ?x!sp:resultVariables!list:member sp:varName ?selectVarName } ?selectVarNames) 
            log:collectAllIn _:t.

      # get all aggregates (function, var, alias)
      ( ( ?aggrFn ?aggrVar ?aggrAlias )
      {
            ?x!sp:resultVariables list:member ?resultVar .
            ?resultVar sp:expression ?exp .
            ?exp a ?aggrFn .
            ?exp!sp:expression!sp:varName e:skolem ?aggrVar .
            ?resultVar sp:varName ?aggrAlias .

      } ?aggrs ) log:collectAllIn _:t .

      # TODO
      # map to N3 builtins before creating the rule
      # (shouldn't rely on aux files when exec N3 rules)

      # from these, get aggr-variable vars
      ( ?aggrVar { ?aggrs list:member ?aggr . ( ?aggr 1 ) list:memberAt ?aggrVar } ?aggrVars ) 
            log:collectAllIn _:t .

      # get the N3 equivalent of the where clause
      ?x!sp:where aux:createGraph ?g .

} => {
      {     # collect all relevant variable values from the WHERE clause
            ( ( ?groupVars ?aggrVars ) ?g ?pairs ) log:collectAllIn _:t .

            ?pairs list:member ( ?groupVal [] ) .

            # collect all corresponding aggr-variables values
            ( ?aggrValueList
            {
                  ?pairs list:member ( ?groupVal ?aggrValueList ) .
                  # ?pair log:equalTo ( ?groupVal ?aggrValueList )
                  # ( ?pair 0 ) list:memberAt ?groupVal .
                  # ( ?pair 1 ) list:memberAt ?aggrValueList
                  
            } ?aggrValueLists ) log:collectAllIn _:t .
            
            # per unique group-variables combination: 
            # a list of values, one for each aggr-variable
            # "aggrValueLists" log:trace ( ?groupVal ?aggrValueLists ) .
            
            ( ?aggrResultCell
            { 
                  # for each aggr-variable entry
                  ?aggrs list:iterate ( ?i ( ?aggrFn ?aggrVar ?aggrAlias ) ) .
                  # "aggr" log:trace ( ?aggrFn ?aggrVar ?aggrAlias ) .  

                  # get all values of the corresponding aggr-variable
                  ( ?aggrValue
                  {
                        ?aggrValueLists list:member ?aggrValueList .
                        ( ?aggrValueList ?i ) list:memberAt ?aggrValue .
                  
                  } ?aggrValues ) log:collectAllIn _:t .

                  # finally, apply the aggr function on the values for the aggr-variable
                  ?aggrValues ?aggrFn ?result .
                  # "result" log:trace ( ?aggrValues ?aggrFn ?result ) .

                  ( ?aggrAlias ?result ) log:equalTo ?aggrResultCell .
            
            } ?aggrResultCells ) log:collectAllIn _:t .
            
            # "aggrResultCells" log:trace ( ?aggrResultCells ) .

            # for each group-variable being returned, get the group value
            ( ( ?groupVarName ?indivGroupVal )
            {
                  ?groupVarNames list:iterate ( ?i ?groupVarName ) .
                  # "T0" log:trace ( ?groupVarName ?selectVarNames ) .

                  # make sure it's being returned
                  ?groupVarName list:in ?selectVarNames .

                  # group-variable value
                  ( ?groupVal ?i ) list:memberAt ?indivGroupVal .
            
            } ?groupResultCells ) log:collectAllIn _:t .

            "groupResultCells" log:trace ( ?groupVal ?groupResultCells ) .

            ( ?aggrResultCells ?groupResultCells ) list:append ?resultCell .

      } => { [] ex:result ?resultCell } .
} .


## select (without aggregate result variables)
{     ?x a sp:Select .
      # does not include any expressions as result variables (i.e., aggregate functions)
      (?e { ?x!sp:resultVariables!list:member sp:expression ?e } ()) log:collectAllIn _:t .

      ?x  sp:where ?where.
      ?x aux:getResultVariables ?outvars.
      ?where aux:createGraph ?g1.

  }=>{?g1 => {[] ex:result ?outvars}.
  }.