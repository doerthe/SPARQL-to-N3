# @alsoload tmp.spin

@prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#> . 
@prefix math: <http://www.w3.org/2000/10/swap/math#> . 
@prefix log: <http://www.w3.org/2000/10/swap/log#> . 
@prefix string: <http://www.w3.org/2000/10/swap/string#> . 
@prefix list: <http://www.w3.org/2000/10/swap/list#> . 
@prefix sp: <http://spinrdf.org/sp#> .
@prefix e: <http://eulersharp.sourceforge.net/2003/03swap/log-rules#>.
@prefix aux: <http://example.org/aux#>.

{
    ?x aux:collectPaths ?paths
} <= {
    ?x a sp:SeqPath ;
        sp:path1 ?p1 ;
        sp:path2 ?p2 .

    ?p1 aux:collectPaths ?p1s .
    ?p2 aux:collectPaths ?p2s .

    ( ?p1s ?p2s ) list:append ?paths .
} .

{
    ?x aux:collectPaths ?paths
} <= {
    ?x a sp:ModPath ;
        sp:subPath ?p ;
        sp:modMin ?min ;
        sp:modMax ?max .

    ?paths log:equalTo ( ( ?p ?min ?max ) )
} .

{
    ?x aux:collectPaths ?paths
} <= {
    _:t log:notIncludes { ?x a sp:SeqPath } .
    _:t log:notIncludes { ?x a sp:ModPath } .
    ?x log:rawType log:Other .

    ?paths log:equalTo ( ( ?x 1 1 ) ) .
} .

# # testing collection of paths
# {
#     ?x sp:where ?where .
#     ?where list:member ?tp .
#     ?tp sp:path ?path .

#     ?path aux:collectPaths ?paths

# } => {
#     <> :out ?paths .
# } .


{   ( ?endIdx ?idxs ) aux:startIdx ?startIdx 

} <= {
    ( ?idxs 0 ) list:memberAt ?endIdx .
    ?startIdx log:equalTo -1 .
} .

{
    ( ?endIdx ?idxs ) aux:startIdx ?startIdx 

} <= {
    ( ?idxs ?i ) list:memberAt ?endIdx .
    ?i math:greaterThan 0 .
    ( ?i -1 ) math:sum ?pi .
    ( ?idxs ?pi ) list:memberAt ?startIdx .
} .


{   ( -1 ?x ) aux:startTriples () } <= {} .

{   ( ?startIdx ?pathVars ) aux:startTriples ?extra

} <= {
    ?startIdx math:greaterThan -1 .

    ( ?pathVars ?startIdx ) list:memberAt ?priorVar .
    ( ?startIdx ?priorVar ) aux:intermResultTriple ?extra .
} .


{   ( ?endIdx ?pathVars ) aux:resultTriples ?extra

} <= {
    ( ?pathVars ?endIdx ) list:memberAt ?curVar .
    ( ?endIdx ?curVar ) aux:intermResultTriple ?extra .
} .


{   ( ?idx ?var ) aux:intermResultTriple ?t

} <= {
    ( "http://example.org/aux#IntermResult" ?idx )!string:concatenation <-log:uri ?resUri .
    ( { ?resUri rdfs:value ?var } ) log:equalTo ?t .
} .


{
    ?x sp:where ?where .

    ?where list:member ?tp .
    ?tp a sp:TriplePath ;
        sp:path ?path .

    # "T0" log:trace ( ?path ) .

    ?path aux:collectPaths ?pathPreds .
    "pathPreds" log:trace ( ?pathPreds ) .

    ?tp!sp:subject log:skolem ?ss .
    ?tp!sp:object log:skolem ?os .

    ?pathPreds list:length ?len .

    ( ?pathVar
    {   ?pathPreds list:iterate ( ?i [] ) .
        ?i math:lessThan ( ?len -1 )!math:sum .
        ?i log:skolem ?pathVar .

    } ?intermPathVars ) log:collectAllIn _:t .

    ( ( ?ss ) ?intermPathVars ( ?os ) ) list:append ?pathVars .

    "pathVars" log:trace ( ?pathVars ) .

    ( ?i
    {
        ?pathPreds list:iterate ( ?i ?pathPred ) .
        ( ?pathPred 2 ) list:memberAt -2 .

    } ?arbits ) log:collectAllIn _:t .

    ( ?arbits ( ?len ) ) list:append ?allIdxs .

    "allIdxs" log:trace ( ?allIdxs ) .

    ?allIdxs list:iterate ( ?i ?endIdx ) .
    ( ?endIdx ?allIdxs ) aux:startIdx ?startIdx .

    ( ?pathTriple
        {   
            ?pathPreds list:iterate ( ?cur ( ?pred [] [] )) .
            ?cur math:greaterThan ?startIdx ; math:notGreaterThan ?endIdx .

            ( ?pathVars ?cur ) list:memberAt ?startVar .
            ( ?cur 1 )  math:sum ?next .
            ( ?pathVars ?next ) list:memberAt ?endVar .

            { ?startVar ?pred ?endVar } log:equalTo ?pathTriple .
        }

    ?pathTriples ) log:collectAllIn _:t .

    ( ?startIdx ?pathVars ) aux:startTriples ?startTriples .
    "startTriples" log:trace ( ?startTriples ) .

    ( ?endIdx ?pathVars ) aux:resultTriples ?resultTriples .
    "resultTriples" log:trace ( ?resultTriples ) .

    ( ?startTriples ?pathTriples ) list:append ?allTriples .

} => {
    <> :out ( ?allTriples ?resultTriples ) .
} .