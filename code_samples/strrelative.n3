@prefix : <http://example.org/> .
@prefix list: <http://www.w3.org/2000/10/swap/list#> .
@prefix log: <http://www.w3.org/2000/10/swap/log#> .
@prefix math: <http://www.w3.org/2000/10/swap/math#> .
@prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
@prefix string: <http://www.w3.org/2000/10/swap/string#> .
@prefix xsd: <http://www.w3.org/2001/XMLSchema#> .

#
{
   ( ?arg1 ?arg2 ) :strbefore ?result 
}
<= 
{
   ( ?arg1 ?arg2 "(.*?)%s.*" ) :strrelative ?result 
} .

#
{
   ( ?arg1 ?arg2 ) :strbefore ?result 
}
<= 
{
   ?arg2 :stripTag "" .
   ?arg1 :matchLangTags ?arg2 .
   #
   ( ?arg1 "" ) :annotateString ?result 
} .

#
{
   ( ?arg1 ?arg2 ) :strafter ?result 
}
<= 
{
   ( ?arg1 ?arg2 ".*?%s(.*)" ) :strrelative ?result 
} .

#
{
   ( ?arg1 ?arg2 ) :strafter ?arg1 
}
<= 
{
   ?arg2 :stripTag "" .
   ?arg1 :matchLangTags ?arg2 .
} .

#
{
   ( ?arg1 ?arg2 ?template ) :strrelative ?result 
}
<= 
{
   # TODO error when not matching (?)
   ?arg1 :matchLangTags ?arg2 .
   
   # make sure there's no tags in str2 
   # (messes up the regex; a bug in eye?)
   ?arg2 :stripTag ?lex2 .
   
   # create regex
   ( ?template ?lex2 ) string:format ?regex .
   #
   (
       {
           # try scraping before/after group from arg1
           ( ?arg1 ?regex ) string:scrape ?untaggedResult .
       }
       {
           # if scrape was successful, copy tag/datatype from arg1
           ( ?arg1 ?untaggedResult ) :annotateString ?result 
       }
       {
           # else, return empty string
           ?result log:equalTo "" 
       }
   ) log:ifThenElseIn _:t .
   #
} .


#
{
   ?str1 :matchLangTags ?str2 
}
<= 
{
   ?str1 :langTag ?str2!:langTag 
} .

#
{
   ?str1 :matchLangTags ?str2 
}
<= 
{
   ?str2 :langTag ( ) 
} .



#
{
   ( ?source ?str ) :annotateString ?annStr 
}
<= 
{
   ?source :langTag ?tags .
   ( ?tags 0 ) list:memberAt ?tag .
    #
   ( ?str ?tag ) log:langlit ?annStr 
} .

#
{
   ( ?source ?str ) :annotateString ?annStr 
}
<= 
{
   ?source :langTag ( ) ;
       :datatype ?datatypes .
   ( ?datatypes 0 ) list:memberAt ?datatype .
   #
   ( ?str ?datatype ) log:dtlit ?annStr .
} .

#
{
   ( ?source ?str ) :annotateString ?str 
}
<= 
{
   ?source :langTag ( ) ;
       :datatype ( ) 
} .



#
{
   ?str :stripTag ?str 
}
<= 
{
   ?str :langTag ( ) 
} .

#
{
   ?str :stripTag ?stripped 
}
<= 
{
   ( ?stripped ?tag ) log:langlit ?str 
} .



#
{
   ?str :langTag ?tags 
}
<= 
{
   (
       ?tag
       {
           ( ?lex ?tag ) log:langlit ?str 
       }
       ?tags
   ) log:collectAllIn _:t .
} .


#
{
   ?str :datatype ?datatypes 
}
<= 
{
   (
       ?datatype
       {
           ( ?lex ?datatype ) log:dtlit ?str 
       }
       ?datatypes
   ) log:collectAllIn _:t .
} .
